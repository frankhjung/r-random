---
title: 'Thoughts on Random Number Generators'
author: '[frank.jung@marlo.com.au](mailto:frank.jung@marlo.com.au)'
date: '`r format(Sys.time(), format="%d %b %Y")`'
output:
  word_document: default
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
require(randtests)
```

One of the first exercises given to me as a student was to write a random number
generator. This turned out to be not so easy. Nowadays, we have a multitude of
functions that will give us pseudorandom numbers, making them easy to generate.
But where are random numbers used? As a developer, we see them mainly being used
by testers. Recently, however we've seen them appear in more and more places -
it seems they are everywhere! Random values are used to generate unique
correlation id's in messages, to generate message payloads of arbitrary size,
for file or directory names. Now they can be used for code testing and in model
simulation.

In this first article we explore some random numbers generators (RNG) that can
be easily invoked from [Bash](https://linux.die.net/man/1/bash). To help compare
each RNG, the random numbers have been [scaled from 0 to
1](https://en.wikipedia.org/wiki/Feature_scaling). Then we will look at tests to
see how random these numbers actually are!

In future articles we will take a closer look at random values used in testing
functions and how they are invaluable in model simulation.

But first lets look at some random number generators that can be used in Bash.

## $RANDOM from Bash

In Bash the shell variable `$RANDOM` is probably the easiest to use. It will
generate a number between 0 and 32767.

For example:

```bash
$ RANDOM=123; echo $RANDOM
2877
```

Here, we have seeded `RANDOM` with a value. Seeding a random variable is
required for reproducible results.

To generate a random integer between `START` and `END` use:

```bash
echo $(( (RANDOM % END) + START ))
```

For example, to simulate 10 rolls of a 6 sided dice:

```bash
#!/bin/bash

RANDOM=123
START=1
END=6

for (( i=0; i<10; i++))
do
  echo -n $(( (RANDOM % END) + START )) " "
done
```

Which yields:

  4  4  4  5  2  3  2  6  3  2

To test how random the Bash `$RANDOM` is we will use the
[randtest](https://cran.r-project.org/web/packages/randtests/randtests.pdf)
package. There are many of tests in this package. The one we will use here is
[Bartels Rank
Test](https://www.rdocumentation.org/packages/randtests/versions/1.0/topics/bartels.rank.test).

Here we are testing for randomness, though the test can also be used to test for
trends or systematic oscillation.

We will generate a list of 100 random decimal numbers between 0 and 1 using:

```bash
#!/bin/bash

for i in $(seq 100)
do 
   echo $(bc <<< "scale=8; $RANDOM/32767")
done > bash-random.num
```

As the p-value is high (> 0.05), the Bartels Rank Test suggests that we can
reject the alternative hypothesis that `$RANDOM` is non-random.

```{r br, echo=FALSE, message=FALSE, warning=FALSE}
brtxt <- readLines(con <- file('/home/frank/dev/gnur/random/bash-random.num'))
close(con)
brnum <- as.numeric(brtxt)
bartels.rank.test(brnum, 'two.sided', pvalue = 'auto')
```

The histrogram of the normalised random numbers *n* is:

```{r brhist, echo=FALSE, message=FALSE, warning=FALSE}
hist(brnum, col = 'purple', main = 'Bash $RANDOM', xlab = '$RANDOM (n/32767)')
```

So, Bash `$RANDOM` is probably random. This is generally good enough for basic
requirements, but probably not suitable for more demanding use cases. So, how
does [Awk](https://www.gnu.org/software/gawk/)'s `rand` fair?

## rand from Awk

Here we are using `rand` function from [GNU
Awk](https://www.gnu.org/software/gawk/) This function generates random numbers
between 0 and 1.

```bash
echo | awk -e 'BEGIN {srand()} {print rand();}'
```

If you don't specify the seed `srand()`, then it will return the same results.

You can also generate random integers between `START` and `END`.

For example, to simulate 10 rolls of a 6 sided dice:

```bash
echo | awk -v S=1 -v E=6 'BEGIN {srand()} {for (i=0; i<10; i++) print int(rand() * E + S);}'
```

To prepare the test data:

```bash
seq 100 | awk -e 'BEGIN {srand()} {print rand();}' > awk-rand.num
```

Again, Bartels Rank Test suggests that Awk's `rand` rejects (p-value > 0.05) the
alternative hypothesis that the sequence produced by the function is non-random:

```{r awk, echo=FALSE}
artxt <- readLines(con <- file('/home/frank/dev/gnur/random/awk-rand.num'))
close(con)
arnum <- as.numeric(artxt)
bartels.rank.test(arnum, 'two.sided', pvalue = 'auto')
```

The histrogram of the random numbers *n* is:

```{r arhist, echo=FALSE, message=FALSE, warning=FALSE}
hist(arnum, col = 'purple', main = 'Awk rand()', xlab = 'rand (n)')
```


## urandom device

The final tool we will look at is the
[/dev/urandom](https://www.systutorials.com/docs/linux/man/4-urandom/) device.
The device provides an interface to the kernels random number generator. This is
a useful tool as it can generate a wide variety of random data.

For example print a list of unsigned decimal using
[od(1)](http://man7.org/linux/man-pages/man1/od.1.html):

```bash
$ seq 5 | xargs -I -- od -vAn -N4 -tu4 /dev/urandom
 3287622437
 3753974622
 2103329150
 1495823055
 2218999858
```

It can also be used to source random hexidecimal values:

```bash
$ seq 5 | xargs -I -- od -vAn -N4 -tx4 /dev/urandom
  e480673d
  bc9f1aa8
  4ece5c41
  cba1e97c
  310001c4
```

Or it can generate a block of 64 random alphanumeric bytes using:

```bash
$ cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 64 | head -n 5
  6mBG7HU2KxwBmRR2CNkEwe2CpxOzuKpGqfUK98GqrthpVQTVTMbSIFKWF6UbXWv2
  vx6IxPHiTW1VaJZgmzug6kmuXP9dOZYMLSKKNYmLoZEc4gcZdoqUrxmIkoagjPcc
  FZHqk0RrNnUMVUOeX5IQGwtX6mfDRtUEAuBYFGIJi61RQ3ISdnta7Dk9gTymYpXo
  ggThurP1Q51k4K0Mi1YApgKYqb9qdNiSWQejMJBI00PuOfQhJeOsUZQrNEekeCEN
  ETLFeRanuBBjVpr0Bm5lcjezn8eyuzNQjM9scgRK2BziIMlQwtkUA4T3MZAUZFk6
```

To test the `urandom` device, we will generate a list of 2 digit values, then
normalise them to range from 0 to 1:

```bash
$ cat /dev/urandom | tr -dc '0-9' | fold -w 2 | awk '{print $1/100}' | head -100 > urandom.num
```

Like the other examples above, the test suggests we can reject the alternative
hypothesis of non-randomness. At least for this sample. 

```{r urandom, echo=FALSE}
urtxt <- readLines(con <- file('/home/frank/dev/gnur/random/urandom.num'))
close(con)
urnum <- as.numeric(urtxt)
bartels.rank.test(urnum, 'two.sided', pvalue = 'auto')
```

The histrogram of the normalised random numbers *n* is:

```{r urhist, echo=FALSE, message=FALSE, warning=FALSE}
hist(urnum, col = 'purple', main = 'urandom device', xlab = 'urandom (n/100)')
```

Of the tools explored, `urandom` is the most versatile. So it has broader
application. The down side is, its results are not
[reproducible](https://en.wikipedia.org/wiki/Reproducibility). This is important
for a reseach and for reproduction of tests.

*Stay tuned for part two to discover how random data can be used in testing code.*

Code for this article can be found [here](https://github.com/frankhjung/random).
