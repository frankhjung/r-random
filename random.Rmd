---
title: 'Thoughts on Random Number Generators'
author: '[frank.jung@marlo.com.au](mailto:frank.jung@marlo.com.au)'
date: '`r format(Sys.time(), format="%d %b %Y")`'
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(randtests)
```

One of the first exercises given to me as a mathematics student was to write a
random number generator (RNG). This turned out to be not so easy. Test sequences
cycled quickly or were too predictable or were not evenly distributed. Typically
when we talk of RNG's we are describing *pseudorandom* number generators.
Nowadays, we have a many programs that will generate *pseudorandom* numbers.

Where are random numbers used? As a developer they were rarely required.
Recently, however we've seen them appear in more and more places - it seems they
are [everywhere](https://en.wikipedia.org/wiki/Applications_of_randomness)!

In DevOps, I've used RNG's for creating message payloads of arbitrary size, and
for file or directory names. These values are often created using scripts
written in [bash](https://linux.die.net/man/1/bash). This first article will
explore three simple RNG's that can be run from bash. It is not an exhaustive
list, as there are others such as [jot](https://man.openbsd.org/jot.1) that is
also easy to use from bash. However, the three described here are likely to
already be installed on your Linux box.

The three RNG's being evaluated here are:

* [Bash](https://linux.die.net/man/1/bash) `RANDOM` variable
* [Awk](https://linux.die.net/man/1/awk) `rand()` function
* [/dev/urandom](https://linux.die.net/man/4/urandom) device

**Words of caution:** 

None of these tools are suitable for generating passwords or for cryptography.

Source and test data for this article can be found
[here](https://github.com/frankhjung/random).

In future articles we will take a closer look at random values used in testing
code and how they can be used for model simulation in statistics.

## Testing Numeric Sequences

This discussion will not test the programs for randomness. Instead, we are going
to evaluate a short list of 1000 values generated by each RNG. To ease
comparison the values will be scaled to the range `[0,1)`. They are rounded to
two decimal places and the list of values is formatted as `0.nn`.

There are many tests that can be applied to sequences to check for randomness.
Here we are only looking at one: the [Bartels Rank
test](https://www.rdocumentation.org/packages/randtests/versions/1.0/topics/bartels.rank.test).
It's limitations and those of other tests are described
[here](http://www.ifp.illinois.edu/~ywang11/paper/ECE461Proj.pdf). I've choosen
this test as it is relatively easy to understand and interpret. Rather than
comparing the magnitude of each observation with its preceding sample, Bartels
Rank test, ranks all the samples from the smallest to the largest. The rank is
the corresponding sequential number in the list of possibilities. Under the null
hypothesis of randomness, any rank arrangement from all possibilities should be
equiprobable. Bartels Rank test is also [suitable for small
samples](https://www.researchgate.net/publication/230639951_The_Rank_Version_of_von_Neumann's_Ratio_Test_for_Randomness).

To get a feel of the test: consider two of the vignettes provided by the R
package,
[randtests](https://cran.r-project.org/web/packages/randtests/index.html).

### Example 5.1 in Gibbons and Chakraborti (2003), p.98.

Annual data on total number of tourists to the United States for 1970-1982.

```{r example1}
years <- 1970:1982
tourists <- c(12362, 12739, 13057, 13955, 14123, 15698, 17523, 18610, 19842,
20310, 22500, 23080, 21916)
# plot(years, tourists, pch = 20, col = 'purple')
plot(years, tourists, col = 'purple')
bartels.rank.test(tourists, alternative = "left.sided", pvalue = "beta")
```

What this tells us about the sample data is there is strong evidence *against*
the null hypothesis of randomness. Instead, it favours the alternative
hypothesis, that of a trend.

### Example in Bartels (1982)

Changes in stock levels for 1968-1969 to 1977-1978 (in $AUD million), deflated
by the Australian gross domestic product (GDP) price index (base 1966-1967).
[Source](https://www.researchgate.net/publication/230639951_The_Rank_Version_of_von_Neumann's_Ratio_Test_for_Randomness)

```{r example2}
y <- c(528, 348, 264, -20, -167, 575, 410, -4, 430, -122)
x1 <- 1968:1977
x2 <- 1969:1978
df <- data.frame(period = paste(sep = '-', x1, x2), gdp = y, stringsAsFactors = TRUE)
plot(df, xlab = 'Financial Year', ylab = 'GDP ($AUD million)')
bartels.rank.test(y, pvalue = 'beta')
```

Here, the sampled data provides weak evidence against the null hypothesis of
randomness. Which does not support the alternative hypothesis of non-random
data.

(For a simple guide on how to interpret the p-value, see
[this](https://www.dummies.com/education/math/statistics/what-a-p-value-tells-you-about-statistical-data/))

## Random Number Generators that can be used in Bash scripts

The following sections describe 3 RNG's. It includes a small description with
typical use of the RNG. Then a list of 1000 values is produced and analysed
using Bartels Rank test.

### bash RANDOM variable

Bash, provides the shell variable
[$RANDOM](http://tldp.org/LDP/abs/html/randomvar.html). It will generate a
pseudorandom signed 16-bit integer between 0 and 32767.

`RANDOM` is easy to use is bash:

```{bash bashrandom}
RANDOM=314
echo $RANDOM
```

Here, we have seeded `RANDOM` with a value. Seeding a random variable will
return the same sequence of numbers. This is required for results to be
[reproducible](https://en.wikipedia.org/wiki/Reproducibility).

To generate a random integer between `START` and `END` use:

```bash
RANGE=$(( END - START + 1))
echo $(( (RANDOM % RANGE) + START ))
```

Where `START` < `END` are non-negative numbers.

For example, to simulate 10 rolls of a 6 sided dice:

```{bash bashrange}
START=1
END=6
RANGE=$(( END - START + 1 ))

RANDOM=314
for i in $(seq 10); do
   echo -n $(( (RANDOM % RANGE) + START )) " "
done
```

#### Checking Sequences from RANDOM

Prepare the test data:

```{bash bashpreparedata}
RANDOM=314
# bc interferes with RANDOM
temprandom=$(mktemp temp.random.XXXXXX)
for i in $(seq 1000); do
   echo "scale=2;$RANDOM/32768"
done > $temprandom
cat $temprandom | bc | awk '{printf "%0.2f\n", $0}' > bash.random
rm $temprandom
```

```{r bashload}
bashText <- readLines(con <- file(paste0(getwd(), '/bash.random')))
close(con)
bashRandom <- as.numeric(bashText)
```

Show first 10 values:

```{r bashhead}
head(bashRandom, n = 10)
```

Plot the sequence vs value from RNG:

```{r bashplot}
plot(x = seq(1000), y = bashRandom, 
     xlab = 'sequence', ylab = 'RANDOM', 
     title('bash RANDOM'), 
     pch = 20, cex = 0.4, col = 'purple')
```

Run Bartels Rank test:

```{r bashtest}
bartels.rank.test(bashRandom, 'two.sided', pvalue = 'beta')
```

#### Result

With a p-value > 0.05 there is weak evidence against the null hypothesis of
randomness.


### awk rand()

Here we are using `rand` function from [GNU
Awk](https://www.gnu.org/software/gawk/). This function generates random numbers
between 0 and 1.

Example where `rand()` seeded

```{bash awkrand}
echo | awk -e 'BEGIN {srand(314)} {print rand();}'
```

If you don't specify a seed in `srand()` it will return the same results.

You can also generate random integers in a range.

For example, to simulate 10 rolls of a 6 sided dice:

```{bash awkrange}
echo | awk 'BEGIN {srand(314)} {for (i=0; i<10; i++) printf("%d ", int(rand() * 6 + 1));}'
```

#### Checking Sequences from rand()

Prepare the test data:

```{bash awkpreparedata}
seq 1000 | awk -e 'BEGIN {srand(314)} {printf("%0.2f\n",rand());}' > awk.random
```

```{r awkload}
awkText <- readLines(con <- file(paste0(getwd(), '/awk.random')))
close(con)
awkRandom <- as.numeric(awkText)
```

Show first 10 values:

```{r awkhead}
head(awkRandom, n = 10)
```

Plot the sequence vs value from RNG:

```{r awkplot}
plot(x = seq(1000), y = awkRandom, 
     xlab = 'sequence', ylab = 'rand()', 
     title('awk rand()'), 
     pch = 20, cex = 0.4, col = 'purple')
```

Run Bartels Rank test:

```{r awktest}
bartels.rank.test(awkRandom, 'two.sided', pvalue = 'beta')
```

#### Result

With a p-value > 0.05 there is weak evidence against the null hypothesis of
randomness.


### urandom device

The final tool we will look at is the
[/dev/urandom](https://www.systutorials.com/docs/linux/man/4-urandom/) device.
The device provides an interface to the kernels random number generator. This is
a useful tool as it can generate a wide variety of data types.

For example print a list of unsigned decimal using
[od(1)](http://man7.org/linux/man-pages/man1/od.1.html):

```{bash urandomdec}
seq 5 | xargs -I -- od -vAn -N4 -tu4 /dev/urandom
```

It can also be used to source random hexadecimal values:

```{bash urandomhex}
seq 5 | xargs -I -- od -vAn -N4 -tx4 /dev/urandom
```

Or it can generate a block of 64 random alphanumeric bytes using:

```{bash urandomblock}
cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 64 | head -n 5
```

#### Checking Sequences from urandom

Prepare the test data:

```{bash urandompreparedata}
cat /dev/urandom | tr -dc  '0-9' | fold -w2 | \
	awk '{printf("0.%02d\n",$1)}' | head -1000 > urandom.random
```

```{r urandomload}
urText <- readLines(con <- file(paste0(getwd(), '/urandom.random')))
close(con)
urRandom <- as.numeric(urText)
```

Show first 10 values:

```{r urandomhead}
head(urRandom, n = 10)
```

Plot the sequence vs value from RNG:

```{r urandomplot}
plot(x = seq(1000), y = urRandom, 
     xlab = 'sequence', ylab = 'urandom', 
     title('/dev/urandom'), 
     pch = 20, cex = 0.4, col = 'purple')
```

Run Bartels Rank test:

```{r urandomtest}
bartels.rank.test(urRandom, 'two.sided', pvalue = 'beta')
```

#### Result

With a p-value > 0.05 there is weak evidence against the null hypothesis of
randomness.


## Some final thoughts

Of the tools explored, `urandom` is the most versatile. So it has broader
application. The down side is, its results are not easily
[reproducible](https://en.wikipedia.org/wiki/Reproducibility) and issues have
been identified by a study by [Gutterman, Zvi; Pinkas, Benny; Reinman, Tzachy
(2006-03-06)](http://www.pinkas.net/PAPERS/gpr06.pdf) for the Linux kernel
version 2.6.10.

Personally, this has been a useful learning exercise. For one it showed the
limitations in generating and testing for (psuedo)random sequences. Indeed,
[Aaron Roth](https://www.quora.com/profile/Aaron-Roth), has
[suggested](https://www.quora.com/How-do-I-measure-the-randomness-of-a-sequence):

> As others have mentioned, a fixed sequence is a deterministic object, but you
can still meaningfully talk about how "random" it is using Kolmogorov
Complexity: (Kolmogorov complexity). Intuitively, a Kolmogorov random object is
one that cannot be compressed. Sequences that are drawn from truly random
sources are Kolmogorov random with extremely high probability.
> 
> Unfortunately, it is not possible to compute the Kolmogorov complexity of
sequences in general (it is an undecidable property of strings). However, you
can still estimate it simply by trying to compress the sequence. Run it through
a Zip compression engine, or anything else. If the algorithm succeeds in
achieving significant compression, then this certifies that the sequence is
-not- Kolmogorov random, and hence very likely was not drawn from a random
source. If the compression fails, of course, it doesn't prove that the sequence
has high Kolmogorov complexity (since you are just using a heuristic algorithm,
not the optimal (undecidable) compression). But at least you can certify the
answer in one direction.

In light of this knowledge, lets run the compression tests for the sequences
above:

```{bash list}
ls -l *.random
```

Compress using [zip](https://linux.die.net/man/1/zip):

```{bash zip}
for z in *.random; do zip ${z%%.random} $z; done
```

Compare this to non-random (trend) data:

```{bash testnonrandom}
for i in $(seq 1000); do printf "0.%02d\n" $(( i % 100 )) ; done > test.trend
zip trend test.trend 
```

Or just constant data:

```{bash testconstant}
for i in $(seq 1000); do echo 0.00 ; done > test.constant
zip constant test.constant 
```

So zipping is a good, if rough, proxy for a measure of randomness.

*Stay tuned for part two to discover how random data can be used in testing code.*
