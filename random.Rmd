---
title: 'Thoughts on Random Number Generators'
author: '[frank.jung@marlo.com.au](mailto:frank.jung@marlo.com.au)'
date: '`r format(Sys.time(), format="%d %b %Y")`'
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(randtests)
```

One of the first exercises given to me as a mathematics student was to write a
random number generator (RNG). This turned out to be not so easy. Test sequences
cycled quickly or were too predictable or were not evenly distributed. Typically
when we talk of RNG's we are describing *pseudorandom* number generators.

Nowadays, we have a multitude of commands that will give us *pseudorandom*
numbers, making them easier to generate. Where are random numbers used? As a
developer I rarely required them. Recently, however we've seen them appear in
more and more places - it seems they are
[everywhere](https://en.wikipedia.org/wiki/Applications_of_randomness)!

In DevOps, I've used random values to generate unique correlation id's in test
messages, for creating message payloads of arbitrary size, for file or directory
names. These are often created by scripts written in
[bash](https://linux.die.net/man/1/bash), so the following examples are targeted
towards use in bash scripts.

This first article will explore some (pseudo) RNG's. It is not an exhaustive
list, as there are others such as [jot](https://man.openbsd.org/jot.1) that is
easy to use. The three demonstrated are likely to be already installed on your
Linux box.

Code for this article can be found [here](https://github.com/frankhjung/random).

To help compare each RNG the random numbers have been [scaled from 0 to
1](https://en.wikipedia.org/wiki/Feature_scaling). Then we will look use a
statistical test to see how random the generated numbers actually are!

In future articles we will take a closer look at random values used in testing
code and how they are invaluable in model simulation in statistics.

**A word of caution:** None of these tools are suitable for generating passwords
or for cryptography.

Lets begin by look at some random number generators that can be easily used in
bash.


## $RANDOM from Bash

Bash, provides the shell variable
[$RANDOM](http://tldp.org/LDP/abs/html/randomvar.html). It will generate a
pseudorandom signed 16-bit integer between 0 and 32767. The manual states that
is isn't necessarily a good RNG, but it is easy to use and suitable for our
purposes here.

An example call:

```bash
$ RANDOM=123; echo $RANDOM
2877
```

Here, we have seeded `RANDOM` with a value. Seeding a random variable will
return the same sequence of numbers. This is required for reproducible results.

To generate a random integer between `START` and `END` use:

```bash
echo $(( (RANDOM % END) + START ))
```

For example, to simulate 10 rolls of a 6 sided dice:

```bash
RANDOM=123
START=1
END=6

for (( i=0; i<10; i++))
do
   echo -n $(( (RANDOM % END) + START )) " "
done
```

Which yields:

```
  4  4  4  5  2  3  2  6  3  2
```

To generate a list of 100 RANDOMS:

```bash
RANDOM=123; for i in $(seq 1000000); do echo $RANDOM ; done > ./bash.random
# RANDOM=123; for i in $(seq 1000000); do echo $(bc <<< "scale=8; $RANDOM/32767") ; done > ./bash.random
```

```{r br, echo=FALSE, message=FALSE, warning=FALSE}
bashtext <- readLines(con <- file(paste0(getwd(), '/bash.random')))
close(con)
bashrandom <- as.numeric(bashtext)
bartels.rank.test(bashrandom, 'two.sided', pvalue = 'auto')
```


## rand from Awk

Here we are using `rand` function from [GNU
Awk](https://www.gnu.org/software/gawk/). This function generates random numbers
between 0 and 1.

```bash
echo | awk -e 'BEGIN {srand()} {print rand();}'
```

If you don't specify the seed `srand()`, then it will return the same results.

You can also generate random integers between `START` and `END`.

For example, to simulate 10 rolls of a 6 sided dice:

```bash
echo | awk -v S=1 -v E=6 'BEGIN {srand()} {for (i=0; i<10; i++) print int(rand() * E + S);}'
```

To prepare the test data:

```bash
seq 100 | awk -e 'BEGIN {srand(123)} {print rand();}' > awk.random
```

```{r awk, echo=FALSE}
awktext <- readLines(con <- file(paste0(getwd(), '/awk.random')))
close(con)
awkrandom <- as.numeric(awktext)
```


## urandom device

The final tool we will look at is the
[/dev/urandom](https://www.systutorials.com/docs/linux/man/4-urandom/) device.
The device provides an interface to the kernels random number generator. This is
a useful tool as it can generate a wide variety of random data.

For example print a list of unsigned decimal using
[od(1)](http://man7.org/linux/man-pages/man1/od.1.html):

```bash
$ seq 5 | xargs -I -- od -vAn -N4 -tu4 /dev/urandom
 3287622437
 3753974622
 2103329150
 1495823055
 2218999858
```

It can also be used to source random hexadecimal values:

```bash
$ seq 5 | xargs -I -- od -vAn -N4 -tx4 /dev/urandom
  e480673d
  bc9f1aa8
  4ece5c41
  cba1e97c
  310001c4
```

Or it can generate a block of 64 random alphanumeric bytes using:

```bash
$ cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 64 | head -n 5
  6mBG7HU2KxwBmRR2CNkEwe2CpxOzuKpGqfUK98GqrthpVQTVTMbSIFKWF6UbXWv2
  vx6IxPHiTW1VaJZgmzug6kmuXP9dOZYMLSKKNYmLoZEc4gcZdoqUrxmIkoagjPcc
  FZHqk0RrNnUMVUOeX5IQGwtX6mfDRtUEAuBYFGIJi61RQ3ISdnta7Dk9gTymYpXo
  ggThurP1Q51k4K0Mi1YApgKYqb9qdNiSWQejMJBI00PuOfQhJeOsUZQrNEekeCEN
  ETLFeRanuBBjVpr0Bm5lcjezn8eyuzNQjM9scgRK2BziIMlQwtkUA4T3MZAUZFk6
```

To test the `urandom` device, we will generate a list of 2 digit values, then
normalise them to range from 0 to 1:

```bash
cat /dev/urandom | tr -dc '0-9' | fold -w 2 | head -100 > urandom.random
```

Like the other examples above, the test suggests we can reject the alternative
hypothesis of non-randomness. 

```{r urandom, echo=FALSE}
urandomtext <- readLines(con <- file(paste0(getwd(), '/urandom.random')))
close(con)
urandom <- as.numeric(urandomtext)
```

Of the tools explored, `urandom` is the most versatile. So it has broader
application. The down side is, its results are not easily
[reproducible](https://en.wikipedia.org/wiki/Reproducibility). This makes it
difficult to use for work that requires to reproducible.

*Stay tuned for part two to discover how random data can be used in testing code.*
